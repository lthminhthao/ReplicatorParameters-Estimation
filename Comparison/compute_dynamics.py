#!/usr/bin/env python
# coding: utf-8

# In[1]:


import numpy as np
import matplotlib.pyplot as plt
from scipy import integrate


# In[2]:


#compute fitness matrix from mu value and matrix of interaction
def fitness(A, mu):
    n = len(A)
    return np.array(mu*(A.T - A) + A.T - np.matrix(np.ones((n,1)))* np.matrix( np.diagonal(A)))


# In[3]:


#input the replicator system
def slowdyn(T, z, Lambda = None, D = 1):
    n = len(z)
    
    if type(z) is list:
        z = np.array(z)
    z = np.array([10**(-30) if u<0  else u for u in list(z)])
    z = z/np.sum(z)
    
    if Lambda is None : 
        Lambda = np.array([[]])
        
    if type(Lambda) is list: 
        Lambda = np.array(Lambda)
        
    if np.shape(Lambda) != (len(z),len(z)):
        print('Attention mauvais lambda. Remplacement par une valeur par dÃ©faut')
        Lambda = np.ones((len(z),len(z)))
        
    Lambda = Lambda - np.diag(np.diag(Lambda))
    Q = np.dot(z.T,np.dot(Lambda,z))
    L = np.dot(Lambda,z)

    return D* np.array(z)* (L - Q)


# In[4]:


#solve the ODE of dynamics
def traject(T, X0, fit, D = 1):
    """kwargs=[A,mu] or kwargs=[Lambda]"""

    if type(X0) is list: 
        X0 = np.array(X0)
        
    if (X0 < 0).any(): 
        print('negativ entry')
        return None
    
    if (X0==0).all() : 
        print('no positiv entry')
        return  None
    
    def f_eval(t, X):
        Z = slowdyn(t, X, Lambda = fit, D = D)[:-1]
        return np.concatenate((Z,np.array([-sum(Z)])))
    
    #compute Jacobian matrix for RHS of replicator system
    def jacobian_func(t, z):
    #input: fitness matrix, time, z(t)

        n = len(z)
        jacobian = np.zeros((n, n))
        
        for i in range(0, n):
            for j in range (0, n):
            
                #non-diagonal elements
                if j != i:
                    jacobian[i, j] = fit[i,j]*z[i] - z[i]*np.matmul((fit.T + fit)[j, :], z)
            
                #diagonal elements
                if j == i:
                    jacobian[i, i] = np.matmul(fit[i, :], z) - np.matmul(np.matmul(fit, z), z) - z[i]*np.matmul((fit.T + fit)[i, :], z)
    
        return jacobian
    
    
    resultat = integrate.solve_ivp(fun=f_eval, t_span=(0, T), y0 = X0,
                             method='BDF', jac = jacobian_func,
                             dense_output=True, rtol = 1e-8, atol = 1e-8
                             #t_eval=np.arange(0,T,0.1),
                             )
    return resultat


# In[5]:


"""Compute the dynamics for a n strain system.
    Input are :
    -T the final time 
    -mu the ratio I/D=1/(k(R0-1))
    -A the array of rescalled interactions.  A is automatiquely renormalised such that the euclidian norm is ||A||=1
    -fit the matrix of fitness (usefull if neither mu nor A is given).
    -n the number of species (usefull is neither mu nor A nor fit is given)
    If mu and A are given, the fitness is computed by the function fitness.
    If mu is given and not A, then A is generated randomly using a uniform distribution between -1 and 1
    If A is given and not mu then mu is generated randomly using a uniform distribution between 0 and 10
    If none of mu, A or fit are  given, then mu=1 and A  is generated by using a uniform distribution between -1 and 1.
    
    Additional arguments are 
    -z0 : the initial data
    -V_threshold: If z_i < threshold, then the strain i is considered to be not here
    -T_threshold: a percentage of T from which we compute the threshold. Default is 100%
    The output are mu, A, fit, the resultat of the dynamics and the number of coexistent species
    """
def simu(T, mu, A, z0, T_threshold = None, V_threshold = 10**-4, **kwargs):
    
    n = len(A)
    fit = fitness(A = A, mu = mu)

    ##Computation of the dynamics
    D = kwargs.pop('D', 1)
    resultat = traject(T = T, X0 = z0, fit = fit, D = D)
    if T_threshold is None: 
        nc = len(resultat.y[:,-1][resultat.y[:,-1] > V_threshold])
    
    else:
        Tstart = T*T_threshold
        ind_threshold = np.int( np.min( np.arange(0, len(resultat.t), 1)[resultat.t > Tstart].tolist() + [T]))
        mean = np.mean( resultat.y[:, ind_threshold:], axis=1)
        nc = len(mean[mean > V_threshold])
        
    return mu, A, fit, resultat, nc


# In[6]:


"""Plot the dynamics of the system.
    resultat is an output of the function simu above. 
    If resultat is none then system is simulated using the functino simu with the parameters in kwargs. 
    the input istitle = false remove the title of the function
    the input details give the number of time step in the graph
    """

def plot_dynamics(T, mu, A, z0, isplot = True, ax = None, **kwargs):
    
    details = T*10
    mu, A, fit, resultat, nc = simu(T, mu, A, z0)
        
    D = kwargs.pop('D', 1)
    istitle = kwargs.pop('istitle', True)
    
    T = kwargs.pop('T',resultat.t[-1])
    V_threshold = kwargs.pop('V_threshold', 10**-4)
    T_threshold = kwargs.pop('T_threshold', 1)
    
    n = len(resultat.y)
    if ax is None: 
        fig,ax = plt.subplots() 
        
    y = resultat.sol(np.linspace(0, T, details))
    
    for i in range(np.shape(resultat.y)[0]):
        ax.plot(np.linspace(0, T, details), y[i], **kwargs, visible = isplot)
        
    if istitle:
        titre = 'N={} strains and '.format(n) 
        coexist = (nc > 1)*'{} strains coexist'.format(nc) + (nc == 1)*'1 strain survives '
        mean = '\n(mean> {:0.0e} on the last {:0.0f}% of time) '.format(V_threshold, (1 - T_threshold)*100)
        ax.set_title(titre + coexist + mean) 
        
    ax.set_xlabel('Time ' + r'$\tau$', fontsize = 25)
    ax.set_ylabel('Strain frequency $z_i$', fontsize = 25)
    ax.yaxis.set_ticks_position('left')
    
    RETURN = {}
    RETURN['mu'] = mu
    RETURN['A'] = A
    RETURN['fit'] = fit
    RETURN['res'] = resultat
    RETURN['nc'] = nc
    
    return RETURN, ax


# In[7]:


#Compute the fitness matrix
def fitness_matrix(strain_number, mu, alpha):
    lambd = np.zeros((strain_number, strain_number))
    
    for i in range (0, strain_number):
        for j in range (0, strain_number):
            lambd[i][j] = mu*(alpha[j][i] - alpha[i][j]) + alpha[j][i] - alpha[j][j]

    return lambd


# In[8]:


# compute the equilibrium of predicted model
def equil(lambd):
    strain_number = len(lambd[0,:])
    one = np.ones(strain_number) #vector of all ones
    inv = np.linalg.inv(lambd) #inverse matrix of fitness matrix
    z = (1/np.matmul(one.T, np.matmul(inv, one)))*np.matmul(inv, one)
    
    return z

